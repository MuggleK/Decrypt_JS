此解密主要针对智联招聘中的详情页中的cookie的混淆JS进行解密。   

get请求时，需请求两次；第一次请求会返回一个生成cookie的JS代码，并将生成的cookie作为第二次请求的cookie，否则将请求失败。  

返回的cookie生成代码为混淆JS加密  

代码可分成三块：  
1.代码开始定义了arg1(用于后面对arg2的加密，动态生成，需先请求一次获取arg1来加密出arg2，再携带生成的arg2进行二次访问)和一个大数组；  
  紧接着就是一个匿名函数（无需调用，自动执行），对这个大数组进行改造，得到新的大数组；  
2._0x55f3这个函数是对字符串进行加密，可通过python进行复写
3.l()可视作一个调度函数，最后返回的arg2即我们想要的cookie中唯一有效的acw_sc__v2


爬坑：  
一.对变量名，函数名，数字等进行加密或16进制转码  
特别是对于我们想要的结果arg2的隐藏：  
setTimeout('\x72\x65\x6c\x6f\x61\x64\x28\x61\x72\x67\x32\x29',0x2)；  
其中setTimeout函数的第一个参数解密出来即为reload(arg2)，则可看出，整个代码返回的arg2就是cookie中的acw_sc__v2。  

二.在大数组改造函数中的以下代码  
var _0x4a2aed = function() {  
     var _0x124d17 = new RegExp('\\w+ *\\(\\) *{\\w+ *[\'|\"].+[\'|\"];? *}');  
     return _0x124d17['test'](_0xb8360b['removeCookie']['toString']());  
};  
可以看出这里的正则，是用于防止代码格式化；  
我们习惯性的把JS拿下来就会格式化以看起来方便，所以就会陷入坑里。

解决：1.不对代码进行格式化美观，第一次请求时返回的代码就是没有格式化的，很长一串；但是看起来繁琐且不便调试；  
2.通过观察，这里仅仅只是为了防止换行，而没有其他对数组或其他操作，所以我们可直接返回_0xb8360b['removeCookie']['toString']()，直接规避正则匹配。  

三.在对字符串加密函数_0x55f3中有许多死循环，导致调试时内存溢出  
解决：观察在这个函数中是否对结果有影响，若没有影响则直接注释循环，返回最终值  

2021.9.3 更新python对js算法复写
